#include QMK_KEYBOARD_H
#include "mikelu.h"
#include "custom_shift_keys.h"
#include <stdio.h>
#ifdef STENO_ENABLE
#include "keymap_steno.h"

void eeconfig_init_user() {
    steno_set_mode(STENO_MODE_GEMINI);
}
#endif



user_config_t user_config;

#ifdef KEY_OVERRIDE_ENABLE
const key_override_t esc_override = ko_make_basic(MOD_MASK_GUI, KC_ESC, G(KC_GRAVE));
const key_override_t dqt_override = ko_make_basic(MOD_MASK_SHIFT, KC_GRV, KC_DQT);

// This globally defines all key overrides to be used
const key_override_t **key_overrides = (const key_override_t *[]){
    &esc_override,
    &dqt_override,
    NULL // Null terminate the array of overrides!
};
#endif

const uint16_t PROGMEM arrows_combo[] = {KC_Q, KC_J, KC_K, COMBO_END};
const uint16_t PROGMEM bspc_combo[] = {KC_COMM, KC_DOT, COMBO_END};
const uint16_t PROGMEM slsh_combo[] = {KC_R, KC_L, COMBO_END};
const uint16_t PROGMEM mins_combo[] = {KC_R, KC_S, COMBO_END};
const uint16_t PROGMEM eql_combo[] = {ALT_HR, KC_Z, COMBO_END};
const uint16_t PROGMEM ceql_combo[] = {ALT_HR2, TABD_N, COMBO_END};

combo_t key_combos[COMBO_COUNT] = {
    [OEU_ARROWS] = COMBO_ACTION(arrows_combo),
    [ACOM_BSPC]  = COMBO(bspc_combo, KC_BSPC),
    [RL_SLSH]    = COMBO(slsh_combo, KC_SLSH),
    [RS_MINS]    = COMBO(mins_combo, KC_MINS),
    [NZ_EQL]     = COMBO(eql_combo, KC_EQL),
    [RP_CEQL]    = COMBO(ceql_combo, COL_EQL),
};

void process_combo_event(uint16_t combo_index, bool pressed) {
    switch (combo_index) {
        case OEU_ARROWS:
            //enum layers l = _ARROWS;
            if (pressed) {
                layer_on(_ARROWS);
            } else {
                layer_off(_ARROWS);
            }
            break;
    }
}

// see this link for more info on this:
// https://getreuer.info/posts/keyboards/custom-shift-keys/index.html
const custom_shift_key_t custom_shift_keys[] = {
  {KC_EXLM, KC_1}, 
  {ALT_HL2, KC_2},
  {GUI_HL2, KC_3},
  {CTL_HL2, KC_4},
  {KC_PERC, KC_5},
  {KC_CIRC, KC_6},
  {CTL_HR2, KC_7},
  {GUI_HR2, KC_8},
  {ALT_HR2, KC_9},
  {KC_RPRN, KC_0},
  {KC_MINS, KC_MINS},
  {KC_LBRC, KC_LBRC},
  {KC_RBRC, KC_RBRC},
};

uint8_t NUM_CUSTOM_SHIFT_KEYS =
    sizeof(custom_shift_keys) / sizeof(custom_shift_key_t);


void keyboard_post_init_user(void) {
    // Call the keymap level matrix init.

    // Read the user config from EEPROM
    user_config.raw = eeconfig_read_user();
}

uint16_t get_tapping_term(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case CTL_HR:
        case CTL_HL:
        case ALT_HR:
        case ALT_HL:
        case GUI_HL:
        case GUI_HR:
        case CTL_HR2:
        case CTL_HL2:
        case ALT_HR2:
        case ALT_HL2:
        case GUI_HL2:
        case GUI_HR2:
            return TAPPING_TERM + 100;
        case SFT_ENT:
            return TAPPING_TERM + 20;
        default:
            return TAPPING_TERM+100;
    }
}

layer_state_t layer_state_set_user(layer_state_t state) { return update_tri_layer_state(state, _LOWER, _RAISE, _ADJUST); }

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
  if (!process_custom_shift_keys(keycode, record)) { return false; }

  switch (keycode) {
        // differences based on os'
        case AUTOFIL:
            if (record->event.pressed) {
                if (!user_config.is_windows) {
                    SEND_STRING(SS_LGUI("\\"));
                } else {
                    SEND_STRING(SS_LCTL("\\"));
                }
            }
            return false;
            break;
        case SRCHPWD:
            if (record->event.pressed) {
                if (!user_config.is_windows) {
                    SEND_STRING(SS_LGUI(SS_LALT("\\")));
                } else {
                    SEND_STRING(SS_LCTL(SS_LALT("\\")));
                }
            }
            return false;
            break;
        case SWPL:
            if (record->event.pressed) {
                if (!user_config.is_windows) {
                    SEND_STRING(SS_LCTL(SS_TAP(X_LEFT)));
                } else {
                    SEND_STRING(SS_LCTL(SS_LGUI(SS_TAP(X_LEFT))));
                }
            }
            return false;
            break;
        case SWPR:
            if (record->event.pressed) {
                if (!user_config.is_windows) {
                    SEND_STRING(SS_LCTL(SS_TAP(X_RIGHT)));
                } else {
                    SEND_STRING(SS_LCTL(SS_LGUI(SS_TAP(X_RIGHT))));
                }
            }
            return false;
            break;
        case ALT_L:
            if (record->event.pressed) {
                if (!user_config.is_windows) {
                    SEND_STRING(SS_LALT(SS_TAP(X_LEFT)));
                } else {
                    SEND_STRING(SS_LCTL(SS_TAP(X_LEFT)));
                }
            }
            return false;
            break;
        case ALT_R:
            if (record->event.pressed) {
                if (!user_config.is_windows) {
                    SEND_STRING(SS_LALT(SS_TAP(X_RIGHT)));
                } else {
                    SEND_STRING(SS_LCTL(SS_TAP(X_RIGHT)));
                }
            }
            return false;
            break;
        case DSP_OFF:
            if (record->event.pressed) {
                if (!user_config.is_windows) {
                    SEND_STRING(SS_LCTL(SS_LGUI("q")));
                } else {
                    SEND_STRING(SS_LGUI("l"));
                }
            }
            return false;
            break;

        case CHNGOS:
            if (record->event.pressed) {
                user_config.is_windows ^= 1;
                eeconfig_update_user(user_config.raw);
            }
            return false;
            break;

        case DVORAK:
            if (record->event.pressed) {
                set_single_persistent_default_layer(_DVORAK);
            }
            return false;
            break;
        case QWERTY:
            if (record->event.pressed) {
                set_single_persistent_default_layer(_QWERTY);
            }
            return false;
            break;
        case LOWER:
            if (record->event.pressed) {
                layer_on(_LOWER);
                update_tri_layer(_LOWER, _RAISE, _ADJUST);
            } else {
                layer_off(_LOWER);
                update_tri_layer(_LOWER, _RAISE, _ADJUST);
            }
            return false;
            break;
        case RAISE:
            if (record->event.pressed) {
                layer_on(_RAISE);
                update_tri_layer(_LOWER, _RAISE, _ADJUST);
            } else {
                layer_off(_RAISE);
                update_tri_layer(_LOWER, _RAISE, _ADJUST);
            }
            return false;
            break;
        case ADJUST:
            if (record->event.pressed) {
                layer_on(_ADJUST);
            } else {
                layer_off(_ADJUST);
            }
            return false;
            break;
        case ARROWS:
            if (record->event.pressed) {
                layer_on(_ARROWS);
            } else {
                layer_off(_ARROWS);
            }
            return false;
            break;
        case COL_EQL:
            if (record->event.pressed) {
                SEND_STRING(SS_DOWN(X_LSHIFT) ";" SS_UP(X_LSHIFT) "=");
            }
            return false;
            break;
        case CTL_HR:
            if (record->event.pressed && record->tap.count > 0) {
                if (!mod_tap_override(KC_RGUI, KC_T, KC_H)) {
                    return false;
                }
            }
            return true;
            break;
        case GUI_HR:
            if (record->event.pressed && record->tap.count > 0) {
                if (!mod_tap_override(KC_RALT, KC_N, KC_T)) {
                    return false;
                }
            }
            return true;
        case KC_G:
            if (record->event.pressed) {
                if (!mod_tap_override(KC_RALT, KC_N, KC_G)) {
                    return false;
                }
            }
            return true;
        case KC_F:
            if (record->event.pressed) {
                if (!mod_tap_override(KC_LALT, KC_O, KC_F)) {
                    return false;
                }
            }
            return true;
        case KC_R:
            if (record->event.pressed) {
                if (!mod_tap_override(KC_LGUI, KC_E, KC_R)) {
                    return false;
                }
            }
        return true;
        case KC_A:
            if (record->event.pressed) {
                if (!mod_tap_override(KC_RCTL, KC_H, KC_A)) {
                    return false;
                }
                if (!mod_tap_override(KC_LCTL, KC_U, KC_A)) {
                    return false;
                }
            }
            return true;
    case ALT_HL2:
        return num_mod(record, KC_AT);
    case GUI_HL2:
        return num_mod(record, KC_HASH);
    case CTL_HL2:
        return num_mod(record, KC_DLR);
    case ALT_HR2:
        return num_mod(record, KC_LPRN);
    case GUI_HR2:
        return num_mod(record, KC_ASTR);
    case CTL_HR2:
        return num_mod(record, KC_AMPR);
#ifdef STENO_ENABLE
    case PLOVER:
      if (record->event.pressed) {
        layer_off(_RAISE);
        layer_off(_LOWER);
        layer_off(_ADJUST);
        layer_on(_PLOVER);
      }
      return false;
      break;
    case EXT_PLV:
      if (record->event.pressed) {
        layer_off(_PLOVER);
      }
      return false;
      break;
#endif
    case GAME:
      if (record->event.pressed) {
        layer_off(_RAISE);
        layer_off(_LOWER);
        layer_off(_ADJUST);
        layer_on(_GAME);
      }
      return false;
      break;
    case EXT_GME:
      if (record->event.pressed) {
        layer_off(_GAME);
      }
      return false;
      break;
    }
    return true;
}

bool num_mod(keyrecord_t *record, uint16_t key) {
    if (record->tap.count > 0) {
        if (record->event.pressed) {
            tap_code16(key);
        }
        return false;
    }
    return true;
}

bool mod_tap_override(uint16_t mod, uint16_t key1, uint16_t key2) {
    if (get_mods() & MOD_BIT(mod)) {
        unregister_mods(MOD_BIT(mod));
        tap_code(key1);
        tap_code(key2);
        add_mods(MOD_BIT(mod));
        return false;
    }
    return true;
}

#ifdef OLED_ENABLE
oled_rotation_t oled_init_user(oled_rotation_t rotation) { return OLED_ROTATION_180; }

static void render_kyria_logo(void) {
    static const char PROGMEM gp_logo[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xe0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xe0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x3f, 0x3f, 0x3f, 0x3f, 0x3e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
                                           0x00, 0x00, 0x00, 0x1e, 0x1e, 0x1e, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x1e, 0x1e, 0x1e, 0x1e, 0x3e, 0x3e, 0x7e, 0xfc, 0xfc, 0xf8, 0xf0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xf0, 0xe0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                           0xff, 0xff, 0xff, 0xff, 0xff, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0xf3, 0xf9, 0xfd, 0xff, 0xff, 0xff, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7e, 0x3f, 0x3f, 0x1f, 0x1f, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    oled_write_raw_P(gp_logo, sizeof(gp_logo));
}

static void render_status(void) {
    oled_write_P(PSTR("Kyria\n\n"), false);

    // Host Keyboard Layer Status
    oled_write_P(PSTR("Layer: "), false);
    switch (get_highest_layer(layer_state)) {
        case _DVORAK:
            if (get_highest_layer(default_layer_state) == _DVORAK) {
                oled_write_P(PSTR("Dvorak\n"), false);
            } else {
                oled_write_P(PSTR("Qwerty\n"), false);
            }
            break;
        case _LOWER:
            oled_write_P(PSTR("Lower\n"), false);
            break;
        case _RAISE:
            oled_write_P(PSTR("Raise\n"), false);
            break;
        case _ADJUST:
            oled_write_P(PSTR("Adjust\n"), false);
            break;
        case _ARROWS:
            oled_write_P(PSTR("Arrow\n"), false);
            break;
        default:
            oled_write_P(PSTR("Undef\n"), false);
    }
    oled_write_P(PSTR("OS: "), false);
    if (user_config.is_windows) {
        oled_write_P(PSTR("Win\n"), false);
    } else {
        oled_write_P(PSTR("Mac\n"), false);
    }
}

bool oled_task_user(void) {
    if (is_keyboard_master()) {
        render_status();  // Renders the current keyboard state (layer, lock, caps, scroll, etc)
    } else {
        render_kyria_logo();
    }
    return false;
}
#endif

#ifdef ENCODER_ENABLE
void encoder_update_user(uint8_t index, bool clockwise) {
    if (index == 0) {
        // Volume control
        if (clockwise) {
            tap_code(KC_VOLU);
        } else {
            tap_code(KC_VOLD);
        }
    } else if (index == 1) {
        // Page up/Page down
        if (clockwise) {
            tap_code(KC_PGDN);
        } else {
            tap_code(KC_PGUP);
        }
    }
}
#endif
